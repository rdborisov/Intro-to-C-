**Дано**: 2 числа M, N;
**Задача**: Написать программу для вычисления функции Аккермана для двух неотрицательных целых чисел m и n, где:
![[Pasted image 20221126144419.png]]

**Решение.** Если известны зависимости, то реализация функции не является трудной задачей. В соответствии с условием задачи функция получает два параметра. Это есть неотрицательные целые числа _n_ и _m_. Возвращает функция также целое неотрицательное число.

При больших значениях _n_ и _m_ может возникнуть переполнение стека, так как функция Аккермана есть дважды рекурсивной: один из аргументов функции есть та же рекурсивная функция.

При вызове функции с параметрами m = 4, n = 4 уже происходит переполнение стека:

![[Pasted image 20221126150112.png]]

Функция Аккермана на языке С#:
```
static int Akkerman(int m, int n)
{
  if (m == 0)
    return n + 1;
  else
    if ((m != 0) && (n == 0))
      return Akkerman(m - 1, 1);
    else
      return Akkerman(m - 1, Akkerman(m, n - 1));
}
```

Функция Аккермана в силу своего определения имеет очень глубокий уровень рекурсии, что можно использовать для проверки способности компилятора оптимизировать рекурсию. Первым функцию Аккермана для этого использовал Ингви Сандблад Брайан Вичман (соавтор [теста производительности](https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D1%81%D1%82_%D0%BF%D1%80%D0%BE%D0%B8%D0%B7%D0%B2%D0%BE%D0%B4%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D0%B8 "Тест производительности") [Whetstone](https://ru.wikipedia.org/wiki/Whetstone "Whetstone")) учёл эту статью при написании серии статей о тестировании оптимизации вызовов.
Один из практичных способов вычисления значений функции Аккермана — [мемоизация](https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D0%BC%D0%BE%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F "Мемоизация") промежуточных результатов. Компилятор может применить эту технику к функции автоматически, используя memo functions
